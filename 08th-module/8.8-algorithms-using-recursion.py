# Рекурсия.
# 1) Вычисление факториала числа.
def factorial(n):
    if n == 1:
        return 1
    return n * factorial(n - 1)


# print(factorial(5))  # 120

# 2) Числа Фибоначчи.
# Числа Фибоначчи — это последовательность чисел, где каждое следующее число равно сумме двух предыдущих.
# Например, первые несколько чисел Фибоначчи: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 и так далее.

def fib(n):
    if n <= 1:
        return n
    return fib(n - 1) + fib(n - 2)


# print([fib(i) for i in range(10)])

# 3) Бинарный поиск.
# Бинарный поиск — это алгоритм поиска элемента в отсортированной последовательности путём её разделения
# на две равные части и поиска элемента в соответствующей половине. Если элемент не найден,
# то поиск повторяется в половине, в которой может быть элемент.
#
# Эту идею мы уже реализовали в задаче «Угадай число», где надо было отгадать загаданное число за семь попыток.
# Также бинарный поиск можно реализовать при помощи рекурсии:

def binary_search(arr, x, start, end):
    # arr — список всех элементов;
    # x — элемент, который мы ищем;
    # start — первый индекс;
    # end — последний индекс;
    # то есть start/end — границы поиска внутри списка.
    if start > end:
        # Если начальный индекс больше конечного, то элемент не найден, возвращаем -1.
        # Это будет значить, что мы не нашли нужное число.
        return None  # - 1
    # Иначе находим индекс среднего элемента.
    mid = (start + end) // 2
    if arr[mid] == x:
        # Если средний элемент равен искомому элементу, то возвращаем его индекс.
        return mid
    elif arr[mid] < x:
        # Если средний элемент меньше искомого элемента, то ищем эл-т во второй половине списка (после среднего эл-та).
        return binary_search(arr, x, mid + 1, end)
    else:
        # Если средний элемент больше искомого элемента, то ищем элемент в первой половине списка (до среднего элемента).
        return binary_search(arr, x, start, mid - 1)


arr = [2, 3, 4, 10, 40]
x = 10
result = binary_search(arr, x, 0, len(arr) - 1)
if result:  # != -1:
    print(f"Элемент найден в индексе {result}")
else:
    print("Элемент не найден")
    
# 4) Глубокое копирование (deep copy) — это процесс создания нового объекта, который является копией другого объекта,
# но при этом все вложенные объекты внутри него также копируются, а не просто ссылаются на исходные объекты.
#
# Работать со вложенными объектами обычными способами довольно непросто (мы заранее можем и не знать,
# сколько в объекте будет уровней вложенности). Но рекурсия как раз отлично подходит для решения таких задач,
# так как для каждой вложенной структуры мы можем сделать свой рекурсивный вызов функции, а он при необходимости
# (если в этом объекте будут вложенные элементы) вызовет для каждого объекта ещё по рекурсивному вызову.
# В итоге мы обработаем все уровни вложенности вне зависимости от того, сколько их будет.
#
# Реализация алгоритма для разных типов данных может выглядеть так:

import copy
def deep_copy(obj):
    if isinstance(obj, (int, float, bool, str)):
        # Если объект относится к простому типу данных (число, строка, булевое значение), то он возвращается как есть,
        # так как не может иметь вложенных объектов.
        return obj
    elif isinstance(obj, list):
        # Если объект представляет собой список, то создаётся новый список, содержащий копии всех элементов
        # исходного списка. При этом для каждого элемента списка рекурсивно вызывается функция deep_copy(),
        # чтобы скопировать его содержимое.
        return [deep_copy(item) for item in obj]
    elif isinstance(obj, dict):
        # Если объект — это словарь, то создаётся новый словарь, содержащий копии всех элементов исходного словаря,
        # так же с вызовом deep_copy для каждого вложенного объекта.
        return {key: deep_copy(value) for key, value in obj.items()}
    else:
        # Если объект не относится к базовому типу и не является списком или словарём,
        # используется метод copy.deepcopy() из стандартной библиотеки Python, чтобы создать глубокую копию.
        return copy.deepcopy(obj)


# Применение рекурсии в этом алгоритме позволяет обрабатывать вложенные объекты разных типов
# и создавать полную глубокую копию исходного объекта, включая все его вложенные элементы.
#
# Важно отметить, что встроенная функция deepcopy() из стандартной библиотеки Python также
# позволяет создать глубокую копию объекта. Однако, если мы используем эту функцию для создания копии объекта,
# который содержит сложные вложенные структуры, это может привести к проблемам с памятью и производительностью.
# Поэтому использование рекурсивного алгоритма глубокого копирования может быть предпочтительнее в таких случаях,
# так как у нас будет больше контроля над процессом (мы можем добавить дополнительные проверки
# и ограничить копирование по своему желанию).

Вот простой пример использования декоратора для синхронизации в Python с использованием модуля `threading`:

```python
import threading

# Глобальная переменная для синхронизации
counter = 0
lock = threading.Lock()

def synchronized(func):
    def wrapper(*args, **kwargs):
        global counter
        with lock:
            counter += 1
            print(f"Запущена функция {func.__name__}, счетчик: {counter}")
            result = func(*args, **kwargs)
            print(f"Завершена функция {func.__name__}, счетчик: {counter}")
            counter -= 1
        return result
    return wrapper

@synchronized
def worker(name):
    # Имитация длительной операции
    import time
    time.sleep(2)
    print(f"Работник {name} выполнил работу")

# Создание и запуск нескольких потоков
threads = []
for i in range(5):
    thread = threading.Thread(target=worker, args=(f"Поток {i}",))
    threads.append(thread)
    thread.start()

# Ожидание завершения всех потоков
for thread in threads:
    thread.join()
```

В этом примере декоратор `synchronized` используется для синхронизации доступа к глобальной переменной `counter` с помощью блокировки `lock` из модуля `threading`.

Разберем работу этого декоратора:

1. Функция `synchronized` принимает функцию `func` в качестве аргумента.
2. Внутри `synchronized` определяется вспомогательная функция `wrapper`.
3. Функция `wrapper` получает блокировку `lock` с помощью оператора `with lock:`.
4. Внутри блока `with` выполняются следующие действия:
   - Увеличивается значение глобальной переменной `counter`.
   - Выводится сообщение о запуске функции `func` и текущее значение `counter`.
   - Вызывается исходная функция `func` с переданными аргументами, и ее результат сохраняется в переменной `result`.
   - Выводится сообщение о завершении функции `func` и текущее значение `counter`.
   - Уменьшается значение глобальной переменной `counter`.
5. Функция `wrapper` возвращает результат `result` исходной функции `func`.
6. Функция `synchronized` возвращает `wrapper`.
7. Декоратор `@synchronized` применяется к функции `worker`.
8. В основной части программы создается несколько потоков, каждый из которых вызывает функцию `worker` с различными аргументами.
9. При вызове `worker` из каждого потока сначала вызывается `wrapper` из декоратора.
10. Внутри `wrapper` блокировка `lock` гарантирует, что только один поток может выполнять критический участок кода (увеличение и уменьшение `counter`) в данный момент времени.
11. Это обеспечивает синхронизацию доступа к глобальной переменной `counter` и предотвращает ее одновременное изменение несколькими потоками.

Этот декоратор синхронизации может быть полезен в многопоточных приложениях, где необходимо защитить доступ к общим ресурсам (переменным, файлам, базам данных и т.д.) от одновременного изменения несколькими потоками.

Обратите внимание, что в этом примере используется блокировка `threading.Lock()`, которая подходит для синхронизации между потоками в одном процессе. Если необходима синхрон